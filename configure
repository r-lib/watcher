#!/bin/sh

# Initialise
PKG_CFLAGS=""
PKG_LIBS="-lpthread"

# Helper function: detect cmake
detect_cmake() {
  if which cmake > /dev/null 2>&1; then
    return 0
  fi
  export PATH=$PATH:/Applications/CMake.app/Contents/bin
  if which cmake > /dev/null 2>&1; then
    return 0
  fi
  echo "Required 'cmake' not found"
  exit 1
}

# Helper function: find library paths
# Usage: find_lib_paths <lib_name> <header_subdir> <default_libs>
# Sets: LIB_CFLAGS, LIB_LIBS
find_lib_paths() {
  lib_name=$1
  header_subdir=$2
  default_libs=$3
  LIB_CFLAGS=""
  LIB_LIBS="$default_libs"

  if [ "$INCLUDE_DIR" ] || [ "$LIB_DIR" ]; then
    LIB_CFLAGS="-I$INCLUDE_DIR"
    LIB_LIBS="-L$LIB_DIR $LIB_LIBS"
    echo "Found INCLUDE_DIR $INCLUDE_DIR"
    echo "Found LIB_DIR $LIB_DIR"
  elif [ -d "/usr/local/include/$header_subdir" ]; then
    LIB_CFLAGS="-I/usr/local/include"
    LIB_LIBS="-L/usr/local/lib $LIB_LIBS"
  elif [ -d "/usr/include/$header_subdir" ]; then
    LIB_CFLAGS="-I/usr/include"
    LIB_LIBS="-L/usr/lib $LIB_LIBS"
  elif [ -d "/usr/local/opt/$lib_name" ]; then
    LIB_CFLAGS="-I/usr/local/opt/$lib_name/include"
    LIB_LIBS="-L/usr/local/opt/$lib_name/lib $LIB_LIBS"
  fi
}

# Find compiler and export flags
CC=`"${R_HOME}/bin/R" CMD config CC`
CFLAGS=`"${R_HOME}/bin/R" CMD config CFLAGS`
CPPFLAGS=`"${R_HOME}/bin/R" CMD config CPPFLAGS`
LDFLAGS=`"${R_HOME}/bin/R" CMD config LDFLAGS`
export CC CFLAGS CPPFLAGS LDFLAGS

if [ -z "$MACOSX_DEPLOYMENT_TARGET" ]; then
  export MACOSX_DEPLOYMENT_TARGET=`echo $CC | sed -En 's/.*-version-min=([0-9][0-9.]*).*/\1/p'`
fi

# Detect -latomic linker flag for ARM architectures (Raspberry Pi etc.)
echo "#include <stdint.h>
uint64_t v;
int main() {
    return (int)__atomic_load_n(&v, __ATOMIC_ACQUIRE);
}" | ${CC} -xc - -o /dev/null > /dev/null 2>&1
if [ $? -ne 0 ]; then
  echo "Adding -latomic linker flag ..."
  PKG_LIBS="$PKG_LIBS -latomic"
fi

# Determine whether to compile bundled library
compile_fswatch=0

if [ -n "$WATCHER_LIBS" ]; then
  echo "WATCHER_LIBS is set... building from source"
  compile_fswatch=1
else
  # Find libfswatch
  find_lib_paths "fswatch" "libfswatch" "-lfswatch"
  FSWATCH_CFLAGS="$LIB_CFLAGS"
  FSWATCH_LIBS="$LIB_LIBS"

  echo "#include <libfswatch/c/libfswatch.h>
int main() {
#if FSW_OK
    *(void *) 0 = 0;
#endif
}" | ${CC} ${FSWATCH_CFLAGS} -xc - -o /dev/null > /dev/null 2>&1
  if [ $? -ne 0 ]; then
    compile_fswatch=1
  else
    echo "Found 'libfswatch' $FSWATCH_CFLAGS"
    PKG_CFLAGS="$FSWATCH_CFLAGS $PKG_CFLAGS"
    PKG_LIBS="$FSWATCH_LIBS $PKG_LIBS"
  fi
fi

# Compile libfswatch if needed
if [ $compile_fswatch -eq 1 ]; then
  echo "Compiling 'libfswatch' from source ..."
  detect_cmake
  cmake -S src/fswatch -B build \
    -DCMAKE_INSTALL_PREFIX=install \
    -DCMAKE_INSTALL_LIBDIR=lib \
    -DCMAKE_BUILD_TYPE=Release \
    -DCMAKE_POSITION_INDEPENDENT_CODE=1 \
    -DCMAKE_COLOR_MAKEFILE=0 \
    -DCMAKE_INSTALL_MESSAGE=NEVER \
    -DBUILD_LIBS_ONLY=1 \
    -DUSE_NLS=0
  cmake --build build --target install
  rm -rf build
fi

# Set flags for bundled library
if [ -d "install/lib" ]; then
  PKG_CFLAGS="-I../install/include $PKG_CFLAGS"
  PKG_LIBS="../install/lib/libfswatch.a $PKG_LIBS"
fi

# Write to Makevars
sed -e "s|@cflags@|$PKG_CFLAGS|" -e "s|@libs@|$PKG_LIBS|" src/Makevars.in > src/Makevars

# Success
exit 0
